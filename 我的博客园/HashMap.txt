基于哈希表的<tt>映射</tt>接口实现。此实现提供所有可选的映射操作，
并允许<tt>null</tt>值和<tt>null</tt>键。（HashMap</tt>类大致等
同于Hashtable</tt>，只是它不同步并且允许空值。）这个类不保证映射的
顺序；特别是，它不保证顺序随时间保持不变。

该实现为基本操作（<tt>get</tt>和<tt>put</tt>）提供恒定的时间性能，
假设哈希函数在存储桶之间正确地分散元素。集合视图上的迭代需要与
<tt>HashMap</tt>实例的“容量”（bucket的数量）加上其大小（键值映射的数量）
成比例的时间。因此，如果迭代性能很重要的话，不要设置太高的初始容量
（或者太低的负载系数）。


<p>HashMap的一个实例有两个影响其性能的参数：<i>初始容量</i>和
<i>负载因子</i>。<i>容量</i>是哈希表中的存储桶数，初始容量只是创建哈希表时的容量。
这个<i>加载因子</i>是在哈希表的容量自动增加之前允许获取的满容量的度量。
当哈希表中的条目数量超过负载因子和当前容量的乘积时，哈希表是<i>重排</i>
（也就是说，内部数据结构被重建），使得哈希表的桶数大约是桶的两倍。

<p>一般来说，默认加载因子（.75）在时间和空间成本之间提供了一个很好的折衷。
较高的值会减少空间开销，但会增加查找成本
（反映在<tt>HashMap</tt>类的大多数操作中，包括<tt>get</tt>和<tt>put</tt>）。
在设置初始容量时，应考虑map中的预期条目数及其负载系数，以尽量减少再冲操作次数。
如果初始容量大于由负载因子除以的条目的最大数量，则不会发生任何重散列操作。


*<p>如果要将许多映射存储在一个<tt>HashMap</tt>实例中，那么创建具有足够大容
量的映射将比让它根据需要执行自动重新灰化以扩展表更有效地存储映射。
请注意，使用多个具有相同{@code hashCode（）}的键肯定会降低任何哈希表的性能。
为了改善影响，当键是{@link Comparable}时，这个类可以使用键之间的比较顺序来帮
助打破联系。

<p><strong>请注意，此实现不同步。</strong>如果多个线程同时访问哈希映射，
并且至少有一个线程在结构上修改了映射，则必须在外部对其进行同步。
（结构修改是添加或删除一个或多个映射的任何操作；仅更改与实例已包含的键
相关联的值不是结构修改。）
这通常通过在自然封装映射的某个对象上进行同步来完成。



如果不存在这样的对象，则应该使用{@ Link Suths:AuthigiDMAP集合.SimuleDeMMA}
方法“映射”该映射。
最好在创建时执行此操作，以防止对映射的意外非同步访问：
<pre>map m=Collections.synchronizedMap（new HashMap（…）；</pre>

*

*<p>这个类的所有“collection view method s”返回的迭代器都是<i>fail fast</i>：
如果在迭代器创建后的任何时候都对映射进行了结构修改，
那么迭代器将抛出一个{@link ConcurrentModificationException}。
因此，在面对并发修改时，迭代器会快速而干净地失败，
而不是在将来某个不确定的时间冒着任意的、不确定的行为的风险。

*

*<p>请注意，不能保证迭代器的fail-fast行为，因为在存在非同步并发修改的情况下，
通常不可能做出任何硬保证。Fail fast迭代器会尽最大努力抛出
ConcurrentModificationException，因此，编写依赖于此异常的程序以确保其正确性是错误的：
<i>迭代器的Fail fast行为应仅用于检测错误。</i>

*<p>该类是

*<a href={@docRoot}/./technotes/guides/collections/index.html“>

*Java集合框架</a>。

*

*@param<K>此映射维护的键类型

*@param<V>映射值的类型

*

*@作者道格・利亚

*@作者乔希・布洛赫

*@作者亚瑟・范霍夫

*@作者尼尔・盖弗

*@请参阅对象hashCode（）

*@查看收藏

*@看地图

*@见TreeMap

*@看